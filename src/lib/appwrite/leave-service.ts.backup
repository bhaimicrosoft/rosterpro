import { databases, DATABASE_ID, COLLECTIONS } from './config';
import { LeaveRequest } from '@/types';
import { Query } from 'appwrite';
import { userService } from './user-service';

export class LeaveService {
  async getAllLeaveRequests(): Promise<LeaveRequest[]> {
    try {
      const response = await databases.listDocuments(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        [Query.orderDesc('$createdAt')]
      );
      return response.documents as unknown as LeaveRequest[];
    } catch (error) {
      
      throw error;
    }
  }

  async getLeaveRequestsByUser(userId: string): Promise<LeaveRequest[]> {
    try {
      const response = await databases.listDocuments(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        [
          Query.equal('userId', userId),
          Query.orderDesc('$createdAt')
        ]
      );
      return response.documents as unknown as LeaveRequest[];
    } catch (error) {
      
      throw error;
    }
  }

  async getPendingLeaveRequests(): Promise<LeaveRequest[]> {
    try {
      const response = await databases.listDocuments(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        [
          Query.equal('status', 'pending'),
          Query.orderDesc('$createdAt')
        ]
      );
      return response.documents as unknown as LeaveRequest[];
    } catch (error) {
      
      throw error;
    }
  }

  async createLeaveRequest(leaveData: Omit<LeaveRequest, '$id' | '$createdAt' | '$updatedAt'>): Promise<LeaveRequest> {
    try {
      const response = await databases.createDocument(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        'unique()',
        leaveData
      );
      return response as unknown as LeaveRequest;
    } catch (error) {
      
      throw error;
    }
  }

  async updateLeaveRequest(leaveId: string, leaveData: Partial<Omit<LeaveRequest, '$id' | '$createdAt' | '$updatedAt'>>): Promise<LeaveRequest> {
    try {
      const response = await databases.updateDocument(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        leaveId,
        leaveData
      );
      return response as unknown as LeaveRequest;
    } catch (error) {
      
      throw error;
    }
  }

  async approveLeaveRequest(leaveId: string): Promise<LeaveRequest> {
    try {
      // First get the leave request to calculate days and get user info
      const leaveRequest = await databases.getDocument(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        leaveId
      ) as unknown as LeaveRequest;

      console.log('Approving leave request:', leaveRequest);

      // Calculate number of days (inclusive of start and end date)
      const startDate = new Date(leaveRequest.startDate);
      const endDate = new Date(leaveRequest.endDate);
      const timeDiff = endDate.getTime() - startDate.getTime();
      const daysDiff = Math.ceil(timeDiff / (1000 * 3600 * 24)) + 1; // +1 to include both start and end dates

      console.log(`Calculated ${daysDiff} days for leave request`);

      // Get current user to get their leave balances
      const user = await userService.getUserById(leaveRequest.userId);
      console.log('Current user leave balances:', {
        paidLeaves: user.paidLeaves,
        sickLeaves: user.sickLeaves,
        compOffs: user.compOffs
      });

      // Calculate new balances based on leave type
      const updateData: { paidLeaves?: number; sickLeaves?: number; compOffs?: number } = {};
      
      switch (leaveRequest.type) {
        case 'PAID':
          updateData.paidLeaves = Math.max(0, (user.paidLeaves || 0) - daysDiff);
          break;
        case 'SICK':
          updateData.sickLeaves = Math.max(0, (user.sickLeaves || 0) - daysDiff);
          break;
        case 'COMP_OFF':
          updateData.compOffs = Math.max(0, (user.compOffs || 0) - daysDiff);
          break;
      }

      console.log('Updating user leave balances:', updateData);

      // Update user's leave balance
      await userService.updateUser(leaveRequest.userId, updateData);

      console.log('Leave balances updated successfully');

      // Update leave request status to approved
      return this.updateLeaveRequest(leaveId, { status: 'APPROVED' });
    } catch (error) {
      console.error('Error in approveLeaveRequest:', error);
      throw error;
    }
  }

  async rejectLeaveRequest(leaveId: string): Promise<LeaveRequest> {
    return this.updateLeaveRequest(leaveId, { status: 'REJECTED' });
  }

  async deleteLeaveRequest(leaveId: string): Promise<void> {
    try {
      await databases.deleteDocument(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        leaveId
      );
    } catch (error) {
      
      throw error;
    }
  }

  async getApprovedLeavesByDateRange(startDate: string, endDate: string): Promise<LeaveRequest[]> {
    try {
      const response = await databases.listDocuments(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        [
          Query.equal('status', 'APPROVED'),
          Query.lessThanEqual('startDate', endDate),
          Query.greaterThanEqual('endDate', startDate),
          Query.orderAsc('startDate')
        ]
      );
      return response.documents as unknown as LeaveRequest[];
    } catch (error) {
      
      throw error;
    }
  }

  async getApprovedLeavesForWeek(startDate: string): Promise<LeaveRequest[]> {
    const endDate = new Date(startDate);
    endDate.setDate(endDate.getDate() + 6);
    return this.getApprovedLeavesByDateRange(startDate, endDate.toISOString().split('T')[0]);
  }

  async isUserOnLeave(userId: string, date: string): Promise<boolean> {
    try {
      const response = await databases.listDocuments(
        DATABASE_ID,
        COLLECTIONS.LEAVES,
        [
          Query.equal('userId', userId),
          Query.equal('status', 'APPROVED'),
          Query.lessThanEqual('startDate', date),
          Query.greaterThanEqual('endDate', date),
          Query.limit(1)
        ]
      );
      return response.documents.length > 0;
    } catch (error) {
      console.error('Error checking if user is on leave:', error);
      return false;
    }
  }

  async cancelLeaveRequest(leaveId: string): Promise<LeaveRequest> {
    return this.updateLeaveRequest(leaveId, { status: 'CANCELLED' });
  }
}

export const leaveService = new LeaveService();
